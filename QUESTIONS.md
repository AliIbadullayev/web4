## 1. Платформа Java EE. Спецификации и их реализации.
Набор спецификаций и соответствующей документации для языка Java, описывающей архитектуру серверной платформы для задач средних и крупных предприятий.

Спецификации детализированы настолько, чтобы обеспечить переносимость программ с одной реализации платформы на другую. Основная цель спецификаций — обеспечить масштабируемость приложений и целостность данных во время работы системы. Java EE во многом ориентирована на использование её через веб, как в интернете, так и в локальных сетях.

Java EE является промышленной технологией и в основном используется в высокопроизводительных проектах, в которых необходима надежность, масштабируемость, гибкость.

Это проект спецификации платформы Java EE. Спецификация платформы Java EE — это общая спецификация, определяющая платформу Java EE. Спецификация платформы не определяет API-интерфейсы Java EE напрямую, а включает их посредством ссылки на другие спецификации Java и определяет, как они все сочетаются друг с другом в общей платформе Java EE. Спецификация платформы также определяет другие атрибуты платформы, такие как безопасность, развертывание, транзакции и совместимость.

**Спецификации API**
Спецификации API для платформы Java EE собраны здесь:

API-интерфейсы Java
Библиотека тегов JSF Facelets
Библиотека тегов JSF JSP
Стандартный HTML RenderKit
Документация JSF по JavaScript

## 2. Принципы IoC, CDI и Location Transpanency. Компоненты и контейнеры.
_Inversion of Control_: объекты создает не программист (используя `new`), а контейнер IoC. Применяется далеко не ко всем объектам в приложении, а только к управляемым
(в Spring это классы с аннотациями `@Component`, `@Service` и т.д., в EJB — бобы `@Stateless`, `@Stateful`, `@MessageDriven`).
Контейнер не только создает объекты, но полностью управляет их жизненным циклом, вызывая на определенных этапах callback методы.
_Dependency injection_:
Вместо построения зависимостей в компоненте, где они нужны:
```java
public class Something {
  private Dependency dependency = new Dependency()
}
```
Мы принимаем их извне, что избавляет компонент от необходимости управлять ими:
```java
public class Something {
  private Dependency dependency;
  public Something (Dependency dependency) {
    this.dependency = dependency;
  }
}  
```
Чтобы нам не пришлость вручную собирать все зависимости для создания компонентов,
контейнер IoC предоставляет возможность внедрения инстанций в поля, помеченные специальной аннотацией:
```java
public class SomethingDI {
  @Autowired private Dependency dependency; // Spring
  @EJB private EjbDependency ejbDependency; // EJB
}
```
## 3. Управление жизненным циклом компонентов. Дескрипторы развёртывания.
### Enterprise JavaBeans (EJB).
EJB-контейнера, поддерживает автоматическое управление жизненным циклом компонента (последовательностью переходов между состояниями типа "отсутствует"–"инициализирован"–"активен") и набором компонентов как ресурсами: удаление компонентов, ставших ненужными; загрузку новых компонентов; балансировку нагрузки между имеющимися компонентами; использование пула готовых к работе, но не инициализированных компонентов, чтобы не тратить время на их удаление и создание, и пр.
### Web-компоненты (Web-components).
**Web-контейнер** реализует такие службы, как управление жизненным циклом компонентов и набором компонентов как ресурсом, распараллеливание независимых работ, выполнение удаленных обращений к компонентам, поддержка защищенности с помощью проверки прав компонентов и пользователей на выполнение различных операций

**Дескриптор развертывания (deployment descriptor)** — описание в определенном формате на основе XML конфигурации компонента в рамках контейнера, в который он помещается. Приложение в целом также имеет дескриптор развертывания. Дескрипторы развертывания играют важную роль, позволяя менять некоторые параметры функционирования компонента и привязывать их к параметрам среды, в рамках которой компонент работает, не затрагивая его код.

## 4. Java EE API. Виды компонентов. Профили платформы Java EE.
Платформа J2EE предназначена в первую очередь для разработки распределенных Web-приложений и поддерживает следующие 4 вида компонентов:
1. Enterprise JavaBeans (EJB).
2. Web-компоненты (Web-components).
3. Обычные приложения на Java.
4. Аплеты (applets).

Существуют **два профиля** (комплектация) платформы JavaEE: `javaee api` ; `javaee web api` 

## 5. Компоненты EJB. Stateless & Stateful Session Beans. EJB Lite и EJB Full.
EJB (Enterprise Java Bean) — спецификация для разработки серверных компонентов, реализующих бизнес-логику.
Компоненты — бобы, которые делятся на _session beans_ (заседательные бобы) и _message driven beans_ (бобы, движимые посланиями).
_Session beans_ в свою очередь делятся на:
* _stateful_: у каждого клиента своя инстанция, в которой хранится его состояние
* _stateless_: одна и та же инстанция обеспечивает запросы нескольких клиентов => лучше масштабируются, но не могут сохранять состояние между последовательными обращениями клиента
* _singleton_: одна инстанция на все приложение => общее для всех клиентов состояние
_Message driven beans_ выполняют метод в ответ на получение сообщения из определенной очереди JMS.
Аннотация `@EJB` предоставляет клиентам не сам объект, а прокси, через который можно получить доступ к методам бизнес-интерфейсов. Может осуществляться доступ как к локальным, так и удаленным (в другой JVM) объектам.

`EJB Light` представляет часть (наиболее часть используемую) функционала по сравнению с полноценным `EJB`, что по идее должно позволять запускать приложения базирующиеся на `EJB Light` на более легковесных версиях серверов приложений (`application server`) так называемый `jee web-profile`. Реализующие web-profile сервера можно посмотреть здесь.

`EJB Light 3.2` поддерживает все то же что и `EJB 3.2` кроме:

* Удаленных интерфейсов (remote interfaces)
* Бинов управляемых сообщениями (message-driven)
* Эндпоинтов для JAX-WS Web-сервисов
* RMI-IIOP
Атрибут persistent для аннотации @Schedule (реализует cron подобный запуск методов)

## 6. Работа с электронной почтой в Java EE. JavaMail API.
`JavaMail` — это `Java API` предназначенное для получения и отправки электронной почты с использованием протоколов `SMTP`, `POP3` и `IMAP`. JavaMail является частью платформы Java EE, но также доступен в качестве дополнительного пакета для использования в приложениях Java SE.

```
Независимая от приложения часть. Интерфейс прикладного программирования (API) используется компонентами 
приложения для отправки и получения почтовых сообщений независимо от используемого основного поставщика или протокола.

Зависимая от службы часть: интерфейс поставщика услуг (SPI) говорит на языках протокола, таких как SMTP, POP, IMAP и протокол передачи
сетевых новостей (NNTP). Он используется для подключения поставщика услуг электронной почты к платформе J2EE.
```
## 7. JMS. Реализация очередей сообщений. Способы доставки сообщений до клиента. Message-Driven Beans.
Java Message Service — стандарт для асинхронного распределенного взаимодействия программных компонентов (которые могут находиться на одном компьютере, в одной локальной сети, или быть связаны через Интернет) путем рассылки сообщений.
JMS поддерживает две модели коммуникации: _point-to-point_ и _publish-subcribe (pubsub)_.
В _point-to-point_ сообщения от разных отправителей адресуются определенной очереди, к которой подключаются клиенты. При этом для каждого сообщения гарантируется, что оно будет доставлено одному и только одному клиенту.
В _pubsub_ сообщения адресуются определенному topic'у, на которые подписываются клиенты. Каждое сообщение может быть получено несколькими клиентами или не получено вообще, если подписчиков на момент доставки не было.
Существует несколько реализаций JMS провайдеров (RabbitMQ, Open Message Queue, ...)

## 8. Понятие транзакции. Управление транзакциями в Java EE. JTA.
Транзакция — группа последовательных операций, представляет собой логическую единицу работы с данными. Транзация либо выполняется успешно и целиком, соблюдая целостность данных, либо не производит никакого эффекта на данные.
_Java Transaction API_ позволяет выполнять распределенные транзакции, т.е. транзакции, читающие и обновляющие данные на разных сетевых ресурсах (которыми могут быть различные серверы баз данных, JMS).
JTA предоставляет высокоуровневый интерфейс для управления транзакиями (begin, commit, rollback), избавляя от необходимости работы с каждым ресурсом по-своему (интерфейс транзакций в JDBC, например, немного отличается от интерфейса JMS).
Транзация координируется transaction manager'ом. Взаимодействие с ресурсами осуществляется через resource manager'ы.
Транзакции могут быть объявлены:
* декларативно — аннотацией `@Transactional` на отдельном методе или всем классе, при этом rollback происходит при необработанном `RuntimeException`
* программно — вызывая `begin`, `rollback`, `commit` у [`UserTransaction`](https://docs.oracle.com/javaee/6/api/javax/transaction/UserTransaction.html)
## 9. Веб-сервисы. Технологии JAX-RS и JAX-WS.
(Немного википедии) \
Веб-служба, веб-сервис (англ. web service) — идентифицируемая уникальным веб-адресом (URL-адресом) программная система со стандартизированными интерфейсами.

Веб-службы могут взаимодействовать друг с другом и со сторонними приложениями посредством сообщений, основанных на определённых протоколах (SOAP, XML-RPC и т. д.) и соглашениях (REST). Веб-служба является единицей модульности при использовании сервис-ориентированной архитектуры приложения.

REST — это архитектурный принцип передачи данных, основанный на веб-стандартах и ​​протоколе HTTP. В REST есть ресурсы, которые размещаются на сервере REST. Каждый ресурс будет иметь уникальный идентификатор, известный как URI, и может быть изменен и доступен с помощью клиента REST.
### JAX-RS
Веб-сервисы RESTful следуют архитектуре на основе REST и в основном используются для веб-сайтов. Это просто и быстро, поскольку оно не ограничено строгими ограничениями и потребляет меньшую пропускную способность.

Java разработала программную спецификацию для создания веб-сервиса в соответствии с архитектурой REST. Название для этой спецификации API — JAX-RS, что означает Java API для RESTful Web Services. 
### JAX-WS
`SOAP` (от англ. Simple Object Access Protocol) — протокол обмена структурированными сообщениями в распределённой вычислительной среде. Первоначально SOAP предназначался в основном для реализации удалённого вызова процедур (RPC). Сейчас протокол используется для обмена произвольными сообщениями в формате XML, а не только для вызова процедур. 

`JAX-WS` — это прикладной программный интерфейс языка Java для создания веб-служб, являющийся частью платформы `Java EE`. JAX-WS является заменой технологии `JAX-RPC`, предоставляя более документо-ориентированную модель сообщений и упрощая разработку[1] веб-служб за счёт использования аннотаций, впервые появившихся в `Java SE 5`
## JavaEE / Spring

**JavaEE**
```
01. JavaEE is a Sun/Oracle standard/specification.	
02. JavaEE is used for web development.	
04. JavaEE has oracle based license.	
05. It is based on three-dimensional architectural frameworks. 	
06. It has an object-oriented language that contains a certain style and syntax.	
07. JavaEE has got good speed.	
08. JavaEE can be web-based or non-web-based.	
09. It is typically got a graphical user interface created from the abstract window toolkit.	
10. JavaEE uses JTA API with the execution.	
```
**Spring**
```
01. Spring is not a standard, strictly speaking, it is a framework.
02. Spring is used for a template design for an application.
04. Spring has an open-source license.
05. It is based on layered architecture containing many modules.
06. It does not has a programming language.
07. Spring is slower than JavaEE.
08. Spring is based on almost 20 modules.
09. This makes the same syntax independent of an IDE.
10. Spring gives a certain layer to help different JTA execution merchants.
```
## 19. Angular: архитектура и основные принципы разработки приложений.
Сам фреймворк состоит из нескольких библиотек (или модулей), каждая из которых содержит в себе определенный функционал, а каждый модуль состоит из совокупности классов и их свойств и методов.

Каждый класс имеет свое функциональное предназначение.


## 20. Angular: модули, компоненты, сервисы и DI.
### Модуль
Разберем модули, именно с них начинается проектирование архитектуры Angular приложения. Каждый из них имеет собственный набор структурных элементов:

`component` - отвечает за часть web-страницы и включает в себя HTML-шаблон, CSS-стили и логику поведения;
`service` - поставщик данных для component;
`directive` - преобразует определенную часть DOM заданным образом.
Все вышеперечисленное собирается в корневой модуль, который общепринято называется `AppModule`.

Корневой модуль может быть только один, но он может использовать функционал других модулей, объявленных в объекте декоратора `@NgModule()` в свойстве imports.

### Компонент
Компонент - это часть интерфейса приложения с собственной логикой. Вся видимая часть Angular App реализуется с помощью компонентов, поэтому часто можно услышать, что архитектура Angular компонентная.

### Сервис

Сервисы нужны для предоставления данных компонентам. Это могут быть не только запросы к серверу, но и функции, преобразующие исходные данные по заданному алгоритму. Они позволяют архитектуре Angular приложения быть более гибкой и масштабируемой.

Задача сервиса должна быть узкой и строго определенной.

Не будет считаться ошибкой, если вы реализуете функционал в компонентах, но считается хорошей практикой все обращения к серверу и функции, возвращающие данные, выносить в сервисы.
Ранее уже упоминалось, что за создание компонента отвечает декоратор `@Component()`. 
## 21. Angular: шаблоны страниц, жизненный цикл компонентов, подключение CSS.
### Шаблоны страниц
Шаблоны == HTML страницы

### Жизненный цикл компонентов
Каждый компонент имеет свой жизненный цикл (Component Lifecycle), в процессе которого вызываются ряд описывающих текущий этап методов (Angular Hooks):
```
OnChanges - устанавливаются или изменяются значения входных свойств класса компонента;
OnInit - устанавливаются "обычные" свойства; вызывается единожды вслед за первым вызовом OnChanges();
DoCheck - происходит изменения свойства или вызывается какое-либо событие;
AfterContentInit - в шаблон включается контент, заключенный между тегами компонента;
AfterContentChecked - аналогичен DoCheck(), только используется для контента, заключенного между тегами компонента;
AfterViewInit - инициализируются компоненты, которые входят в шаблон текущего компонента;
AfterViewChecked - аналогичен DoCheck(), только используется для дочерних компонентов;
OnDestroy - компонент "умирает", т. е. удаляется из DOM-дерева
```
### CSS
Есть три способа задать в Angular CSS-класс элементу. Первый:

`<p [class]="classes">Some text.</p>`
Свойство classes - строка с названием классов, разделенных пробелами. В этом случае текущее значение атрибута class будет перезаписано новым.

Чтобы добавить класс уже к существующим, используется второй способ:


`<p [class.red-text]="isRed">Some text.</p>`
Здесь red-text - название класса, а isRed - переменная компонента типа boolean, значение которой определяет, будет ли в Angular шаблоне установлен класс или нет.

Третий способ задания в Angular CSS-класса - использование директивы `NgClass`, которая рассмотрена в главе "Директивы. Встроенные".

## 22. Angular: клиент-серверное взаимодействие, создание, отправка и валидация данных форм.
